/* eslint-env mocha */

import { resetDatabase } from './00_setup';
import * as chai from 'chai';
import chaiAsPromised from 'chai-as-promised';
import { Roles } from 'meteor/roles';
import '../../imports/server/modules/publications';
import '../methods/auth';
import {
  createManyUsers,
  logOutButLeaveUser,
  stubOtherUser,
  stubUser,
  unwrapUser,
  callMethodWithUser,
} from './mockUser';
import { addPatternDataIndividual } from './testData';
import {
  MAX_RECENTS,
  MAX_TEXT_AREA_LENGTH,
  ROLES,
} from '../../imports/modules/parameters';

chai.use(chaiAsPromised);
const { assert, expect } = chai;

const sinon = require('sinon');

// Re-create all roles after resetDatabase to ensure roles exist for tests
async function ensureAllRolesExist() {
  for (const role of ROLES) {
    if (Roles && typeof Roles.createRoleAsync === 'function') {
      await Roles.createRoleAsync(role, { unlessExists: true });
    } else if (Roles && typeof Roles.createRole === 'function') {
      Roles.createRole(role, { unlessExists: true });
    }
  }

if (Meteor.isServer) {
  describe('test auth methods', function testauthmethods() {
    // We use callMethodWithUser to test methods that require a logged-in user
    // This helper directly invokes the method handler with proper context including userId
    // For testing "not logged in" scenarios, we use Meteor.callAsync with no user stub
    this.timeout(15000);
    beforeEach(async () => {
	unwrapUser(); // Clean up any existing stubs
	await resetDatabase();
	await ensureAllRolesExist(); // Ensure all roles exist after DB reset
    });

    it('throws an error if the user is not logged in', async () => {
      async function expectedError() {
        await Meteor.callAsync('auth.sendVerificationEmail', 'abc');
      }
      await expect(expectedError()).to.be.rejectedWith(
        'send-verification-email-not-logged-in',
      );
    });

      it('sends the email if the user is logged in and unverified', async () => {
        const currentUser = await stubUser();
        assert.isOk(currentUser, 'stubUser() should return a user');
        assert.isOk(currentUser._id, 'stubUser() should return a user with _id');
        // eslint-disable-next-line no-console
        console.log('sendVerificationEmail (unverified): currentUser._id =', currentUser._id);

        await Meteor.users.updateAsync(
          { _id: currentUser._id },
          { $set: { 'emails.0.verified': false } },
        );

        await Roles.createRoleAsync('verified', { unlessExists: true });
        assert.isOk(currentUser._id, 'currentUser._id should be defined for removeUsersFromRolesAsync');
        // eslint-disable-next-line no-console
        console.log('removeUsersFromRolesAsync: currentUser._id =', currentUser._id);
        await Roles.removeUsersFromRolesAsync(currentUser._id, ['verified']);

        const result = await callMethodWithUser(
          currentUser._id,
          'auth.sendVerificationEmail',
          currentUser._id,
        );

        assert.equal(result.email, currentUser.emails[0].address);
      });
    });

    describe('setRecentPatterns method', () => {
      it('throws an error if the user is not logged in', async () => {
        async function expectedError() {
          await Meteor.callAsync('auth.setRecentPatterns', {
            userId: 'xxx',
            newRecentPatterns: [],
          });
        }

        await expect(expectedError()).to.be.rejectedWith(
          'set-recent-patterns-not-logged-in',
        );
      });

      it('adds the recent pattern if the user is logged in', async () => {
        const currentUser = await stubUser();
        assert.isOk(currentUser, 'stubUser() should return a user');
        assert.isOk(currentUser._id, 'stubUser() should return a user with _id');
        // eslint-disable-next-line no-console
        console.log('setRecentPatterns: currentUser._id =', currentUser._id);
        // pattern.add must be called with a valid user context
        const patternId = await callMethodWithUser(
          currentUser._id,
          'pattern.add',
          addPatternDataIndividual,
        );

        await callMethodWithUser(
          currentUser._id,
          'auth.setRecentPatterns',
          {
            userId: currentUser._id,
            newRecentPatterns: [
              {
                currentWeavingRow: 2,
                patternId,
                updatedAt: new Date(),
              },
            ],
          },
        );

        const updated = await Meteor.users.findOneAsync({
          _id: currentUser._id,
        });
        assert.equal(updated.profile.recentPatterns.length, 1);
        assert.equal(
          updated.profile.recentPatterns[0].currentWeavingRow,
          2,
        );
      });

      it('sets current weaving row to 1 if invalid', async () => {
        const currentUser = stubUser();
        assert.isOk(currentUser, 'stubUser() should return a user');
        assert.isOk(currentUser._id, 'stubUser() should return a user with _id');
        // eslint-disable-next-line no-console
        console.log('setRecentPatterns (invalid row): currentUser._id =', currentUser._id);
        // pattern.add must be called with a valid user context
        const patternId = await callMethodWithUser(
          currentUser._id,
          'pattern.add',
          addPatternDataIndividual,
        );

        await callMethodWithUser(
          currentUser._id,
          'auth.setRecentPatterns',
          {
            userId: currentUser._id,
            newRecentPatterns: [
              {
                currentWeavingRow: -1,
                patternId,
                updatedAt: new Date(),
              },
            ],
          },
        );

        const updated = await Meteor.users.findOneAsync({
          _id: currentUser._id,
        });
        assert.equal(updated.profile.recentPatterns.length, 1);
        assert.equal(
          updated.profile.recentPatterns[0].currentWeavingRow,
          1,
        );
      });

      it('stores the maximum number of recents', async () => {
        const currentUser = stubUser();
        assert.isOk(currentUser, 'stubUser() should return a user');
        assert.isOk(currentUser._id, 'stubUser() should return a user with _id');
        // eslint-disable-next-line no-console
        console.log('setRecentPatterns (max recents): currentUser._id =', currentUser._id);
        await Roles.createRoleAsync('verified', { unlessExists: true });
        assert.isOk(currentUser._id, 'currentUser._id should be defined for addUsersToRolesAsync');
        // eslint-disable-next-line no-console
        console.log('addUsersToRolesAsync (max recents): currentUser._id =', currentUser._id);
        await Roles.addUsersToRolesAsync(currentUser._id, ['verified']);

        const newRecentPatterns = [];
        const numberOfRecents = MAX_RECENTS + 5;
        const now = new Date();
        const initialDateAsString = now.toString();

        for (let i = 0; i < numberOfRecents; i += 1) {
          const patternId = await callMethodWithUser(
            currentUser._id,
            'pattern.add',
            addPatternDataIndividual,
          );
          now.setSeconds(now.getSeconds() - 10 * i);
          newRecentPatterns.push({
            currentWeavingRow: 3,
            patternId,
            updatedAt: new Date(now),
          });
        }

        await callMethodWithUser(
          currentUser._id,
          'auth.setRecentPatterns',
          {
            userId: currentUser._id,
            newRecentPatterns,
          },
        );

        const updated = await Meteor.users.findOneAsync({ _id: currentUser._id });
        assert.equal(updated.profile.recentPatterns.length, MAX_RECENTS);

        // the most recent date is the first entry
        assert.equal(
          updated.profile.recentPatterns[0].updatedAt.toString(),
          initialDateAsString,
        );
      });
    });

    describe('register a new user', () => {
      // the tests that rely on Accounts.onCreateUser don't work because Accounts.onCreateUser doesn't run in testing.
      // There is a bug reported but closed:
      // https://github.com/meteor/meteor/issues/7395
      // I've tested this manually and it worked
      it('creates an account with the expected values', async () => {
        const userId = Accounts.createUser({
          email: 'me@there.com',
          username: 'NewUser',
          password: '12345678',
        });

        const { emails, username } = await Meteor.users.findOneAsync({
          _id: userId,
        });

        assert.equal(emails[0].address, 'me@there.com');
        assert.equal(username, 'NewUser');
      });
    });

    describe('get user count', () => {
      // counts all users with public patterns
      // plus the user themselves if logged in
      it('returns the number of users with public patterns if the user is not logged in', async () => {
        const { publicPatternUsernames } = createManyUsers();

        const result = await Meteor.callAsync('auth.getUserCount');

        assert.equal(result, publicPatternUsernames.length);
      });

      it('returns the number of users with public patterns plus one for the user if the user is logged in', async () => {
        const { privatePatternUserIds, publicPatternUsernames } =
          createManyUsers();

        const currentUser = await Meteor.users.findOneAsync({
          _id: privatePatternUserIds[0],
        });
        sinon.stub(Meteor, 'userAsync');
        Meteor.userAsync.returns(currentUser); // now Meteor.userAsync() will return the user we just created

        sinon.stub(Meteor, 'userId');
        Meteor.userId.returns(currentUser._id);

        const result = await Meteor.callAsync('auth.getUserCount');

        assert.equal(result, publicPatternUsernames.length + 1);
        unwrapUser();
      });
    });

    describe('get users for page', () => {
      // counts all users with public patterns
      // returns the number required for the page
      it('returns the users for the first page, user not logged in', async () => {
        const { publicPatternUsernames } = createManyUsers();
        const skip = 0;
        const limit = 10;
        const result = await Meteor.callAsync('auth.getUsersForPage', { skip, limit });
        assert.equal(result.length, limit);
        const expectedUsernames = publicPatternUsernames.sort().slice(0, limit);
        expectedUsernames.forEach((username) => {
          assert.notEqual(expectedUsernames.indexOf(username), -1);
        });
      });

      it('returns the users for the second page, user not logged in', async () => {
        const { publicPatternUsernames } = createManyUsers();
        const skip = 10;
        const limit = 10;
        const result = await Meteor.callAsync('auth.getUsersForPage', { skip, limit });
        assert.equal(result.length, Math.max(0, publicPatternUsernames.length - skip));
      });
    });

    describe('edit text field', () => {
      it('cannot edit description of a different user', async () => {
        async function expectedError() {
          const currentUser = await stubUser();
          stubOtherUser();
          await Meteor.callAsync('auth.editTextField', {
            _id: currentUser._id,
            fieldName: 'description',
            fieldValue: 'someText',
          });
        }
        await expect(expectedError()).to.be.rejectedWith(
          'edit-text-field-not-logged-in',
        );
        unwrapUser();
      });

      it('cannot edit a different field if they are logged in', async () => {
        const currentUser = await stubUser();
        await expect(
          callMethodWithUser(currentUser._id, 'auth.editTextField', {
            _id: currentUser._id,
            fieldName: 'thingy',
            fieldValue: 'someText',
          })
        ).to.be.rejectedWith('edit-text-field-not-allowed');
      });

      it('can edit description if they are logged in', async () => {
        const currentUser = await stubUser();
        assert.equal(currentUser.description, undefined);
        const newDescription = 'Some text';
        await callMethodWithUser(currentUser._id, 'auth.editTextField', {
          _id: currentUser._id,
          fieldName: 'description',
          fieldValue: newDescription,
        });
        const updated = await Meteor.users.findOneAsync({
          _id: currentUser._id,
        });
        assert.equal(updated.description, newDescription);
      });

      it('cannot set a value that is too long', async () => {
        const currentUser = await stubUser();
        assert.equal(currentUser.description, undefined);
        let newDescription = '';
        for (let i = 0; i < MAX_TEXT_AREA_LENGTH; i += 1) {
          newDescription += 'a';
        }
        await callMethodWithUser(currentUser._id, 'auth.editTextField', {
          _id: currentUser._id,
          fieldName: 'description',
          fieldValue: newDescription,
        });
        const updated = await Meteor.users.findOneAsync({
          _id: currentUser._id,
        });
        assert.equal(updated.description, newDescription);
        newDescription += 'longer';
        await expect(
          callMethodWithUser(currentUser._id, 'auth.editTextField', {
            _id: currentUser._id,
            fieldName: 'description',
            fieldValue: newDescription,
          })
        ).to.be.rejectedWith('edit-text-field-too-long');
      });
    });

    describe('add user to role', () => {
      // ...existing code for add user to role...
    });

    describe('remove user from role', () => {
      // ...existing code for remove user from role...
    });

    describe('setWeavingBackwardsBackgroundColor method', () => {
      // ...existing code for setWeavingBackwardsBackgroundColor method...
    });

    describe('edit text field', () => {
      it('cannot edit description of a different user', async () => {
        async function expectedError() {
          const currentUser = await stubUser();
          stubOtherUser();
          await Meteor.callAsync('auth.editTextField', {
            _id: currentUser._id,
            fieldName: 'description',
            fieldValue: 'someText',
          });
        }
        await expect(expectedError()).to.be.rejectedWith(
          'edit-text-field-not-logged-in',
        );
        unwrapUser();
      });

      it('cannot edit a different field if they are logged in', async () => {
        const currentUser = await stubUser();
        await expect(
          callMethodWithUser(currentUser._id, 'auth.editTextField', {
            _id: currentUser._id,
            fieldName: 'thingy',
            fieldValue: 'someText',
          })
        ).to.be.rejectedWith('edit-text-field-not-allowed');
      });

      it('can edit description if they are logged in', async () => {
        const currentUser = await stubUser();
        assert.equal(currentUser.description, undefined);
        const newDescription = 'Some text';
        await callMethodWithUser(currentUser._id, 'auth.editTextField', {
          _id: currentUser._id,
          fieldName: 'description',
          fieldValue: newDescription,
        });
        const updated = await Meteor.users.findOneAsync({
          _id: currentUser._id,
        });
        assert.equal(updated.description, newDescription);
      });

      it('cannot set a value that is too long', async () => {
        const currentUser = await stubUser();
        assert.equal(currentUser.description, undefined);
        let newDescription = '';
        for (let i = 0; i < MAX_TEXT_AREA_LENGTH; i += 1) {
          newDescription += 'a';
        }
        await callMethodWithUser(currentUser._id, 'auth.editTextField', {
          _id: currentUser._id,
          fieldName: 'description',
          fieldValue: newDescription,
        });
        const updated = await Meteor.users.findOneAsync({
          _id: currentUser._id,
        });
        assert.equal(updated.description, newDescription);
        newDescription += 'longer';
        await expect(
          callMethodWithUser(currentUser._id, 'auth.editTextField', {
            _id: currentUser._id,
            fieldName: 'description',
            fieldValue: newDescription,
          })
        ).to.be.rejectedWith('edit-text-field-too-long');
      });
    });

    describe('add user to role', () => {
      it('cannot add a user to a role if the user is not logged in', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        logOutButLeaveUser();
        async function expectedError() {
          await Meteor.callAsync('auth.addUserToRole', {
            _id: targetUser._id,
            role: 'premium',
          });
        }
        await expect(expectedError()).to.be.rejectedWith(
          'add-user-to-role-not-logged-in',
        );
        unwrapUser();
      });
      it('cannot add a user to a role if the user is not an administrator', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        const adminUser = stubOtherUser(); // the administrator

        await expect(
          callMethodWithUser(adminUser._id, 'auth.addUserToRole', {
            _id: targetUser._id,
            role: 'premium',
          })
        ).to.be.rejectedWith('add-user-to-role-not-administrator');
      });
      it('cannot add a user to a role if the user does not exist', async () => {
        await stubUser(); // only so stubOtherUser has something to unwrap
        const adminUser = stubOtherUser(); // the administrator

        await Roles.createRoleAsync('administrator', { unlessExists: true });
        await Roles.addUsersToRolesAsync(adminUser._id, ['administrator']);

        await expect(
          callMethodWithUser(adminUser._id, 'auth.addUserToRole', {
            _id: 'abc',
            role: 'premium',
          })
        ).to.be.rejectedWith('add-user-to-role-user-not-found');
      });

      it('cannot add a user to a role if the role does not exist', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        const adminUser = stubOtherUser(); // the administrator

        await Roles.createRoleAsync('administrator', { unlessExists: true });
        await Roles.addUsersToRolesAsync(adminUser._id, ['administrator']);

        await expect(
          callMethodWithUser(adminUser._id, 'auth.addUserToRole', {
            _id: targetUser._id,
            role: 'aardvark',
          })
        ).to.be.rejectedWith('add-user-to-role-role-not-found');
      });

      it('cannot add a user to a role if the user is already in the role', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        const adminUser = stubOtherUser(); // the administrator

        await Roles.createRoleAsync('administrator', { unlessExists: true });
        await Roles.addUsersToRolesAsync(adminUser._id, ['administrator']);

        await Roles.createRoleAsync('premium', { unlessExists: true });
        await Roles.addUsersToRolesAsync(targetUser._id, ['premium']);

        await expect(
          callMethodWithUser(adminUser._id, 'auth.addUserToRole', {
            _id: targetUser._id,
            role: 'premium',
          })
        ).to.be.rejectedWith('add-user-to-role-already-in-role');
      });

      it('cannot add a user to a role if the user is already in the role', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        const adminUser = stubOtherUser(); // the administrator

        await Roles.createRoleAsync('administrator', { unlessExists: true });
        await Roles.addUsersToRolesAsync(adminUser._id, ['administrator']);

        await Roles.createRoleAsync('premium', { unlessExists: true });

        await callMethodWithUser(adminUser._id, 'auth.addUserToRole', {
          _id: targetUser._id,
          role: 'premium',
        });

        assert.equal(Roles.userIsInRole(targetUser._id, 'premium'), true);
      });
    });

    describe('remove user from role', () => {

      it('cannot remove a user from a role if the user is not logged in', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        logOutButLeaveUser();
        async function expectedError() {
          await Meteor.callAsync('auth.removeUserFromRole', {
            _id: targetUser._id,
            role: 'premium',
          });
        }

        await expect(expectedError()).to.be.rejectedWith(
          'remove-user-from-role-not-logged-in',
        );

        unwrapUser();
      });

      it('cannot remove user from a role if the user is not an administrator', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        const adminUser = stubOtherUser(); // the administrator

        await expect(
          callMethodWithUser(adminUser._id, 'auth.removeUserFromRole', {
            _id: targetUser._id,
            role: 'premium',
          })
        ).to.be.rejectedWith('remove-user-from-role-not-administrator');
      });

      it('cannot remove a user from a role if the user does not exist', async () => {
        await stubUser(); // only so stubOtherUser has something to unwrap
        const adminUser = stubOtherUser(); // the administrator

        await Roles.createRoleAsync('administrator', { unlessExists: true });
        await Roles.addUsersToRolesAsync(adminUser._id, ['administrator']);

        await expect(
          callMethodWithUser(adminUser._id, 'auth.removeUserFromRole', {
            _id: 'abc',
            role: 'premium',
          })
        ).to.be.rejectedWith('remove-user-from-role-user-not-found');
      });

      it('cannot remove a user from a role if the role does not exist', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        const adminUser = stubOtherUser(); // the administrator

        await Roles.createRoleAsync('administrator', { unlessExists: true });
        await Roles.addUsersToRolesAsync(adminUser._id, ['administrator']);

        await expect(
          callMethodWithUser(adminUser._id, 'auth.removeUserFromRole', {
            _id: targetUser._id,
            role: 'aardvark',
          })
        ).to.be.rejectedWith('remove-user-from-role-role-not-found');
      });

      it('cannot remove a user from a role if the user is not in the role', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        const adminUser = stubOtherUser(); // the administrator

        await Roles.createRoleAsync('administrator', { unlessExists: true });
        await Roles.addUsersToRolesAsync(adminUser._id, ['administrator']);

        await Roles.createRoleAsync('premium', { unlessExists: true });

        await expect(
          callMethodWithUser(adminUser._id, 'auth.removeUserFromRole', {
            _id: targetUser._id,
            role: 'premium',
          })
        ).to.be.rejectedWith('remove-user-from-role-not-in-role');
      });

      it('does not allow an administrator to remove themself', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed

        await Roles.createRoleAsync('administrator', { unlessExists: true });
        await Roles.addUsersToRolesAsync(targetUser._id, ['administrator']);

        assert.equal(Roles.userIsInRole(targetUser._id, 'administrator'), true);

        async function expectedError() {
          await Meteor.callAsync('auth.removeUserFromRole', {
            _id: targetUser._id,
            role: 'administrator',
          });
        }

        await expect(expectedError()).to.be.rejectedWith(
          'remove-user-from-role-administrator-not-remove-self',
        );

        assert.equal(Roles.userIsInRole(targetUser._id, 'administrator'), true);

        unwrapUser();
      });

      it('can remove a user from a role', async () => {
        const targetUser = await stubUser(); // the user whose role is to be changed
        const adminUser = stubOtherUser(); // the administrator

        await Roles.createRoleAsync('administrator', { unlessExists: true });
        await Roles.addUsersToRolesAsync(adminUser._id, ['administrator']);

        await Roles.createRoleAsync('premium', { unlessExists: true });
        await Roles.addUsersToRolesAsync(targetUser._id, ['premium']);

        assert.equal(Roles.userIsInRole(targetUser._id, 'premium'), true);

        await callMethodWithUser(adminUser._id, 'auth.removeUserFromRole', {
          _id: targetUser._id,
          role: 'premium',
        });

          assert.equal(await Roles.userIsInRoleAsync(targetUser._id, 'premium'), false);
      });
    });

    describe('setWeavingBackwardsBackgroundColor method', () => {
      it('throws an error if the user is not logged in', async () => {
        async function expectedError() {
          await Meteor.callAsync(
            'auth.setWeavingBackwardsBackgroundColor',
            '#ff00ff',
          );
        }

        await expect(expectedError()).to.be.rejectedWith(
          'set-weaving-backwards-background-color-not-logged-in',
        );
      });

      it('throws an error if the colour value is not specified', async () => {
        await stubUser();

        async function expectedError() {
          await Meteor.callAsync(
            'auth.setWeavingBackwardsBackgroundColor',
            undefined,
          );
        }

        await expect(expectedError()).to.be.rejectedWith('Match error');

        unwrapUser();
      });

      it('throws an error if the colour value is empty string', async () => {
        await stubUser();

        async function expectedError() {
          await Meteor.callAsync('auth.setWeavingBackwardsBackgroundColor', '');
        }

        await expect(expectedError()).to.be.rejectedWith('Match error');

        unwrapUser();
      });
      it('throws an error if the colour value is too long', async () => {
        await stubUser();

        async function expectedError() {
          await Meteor.callAsync(
            'auth.setWeavingBackwardsBackgroundColor',
            '#ff00ffg',
          );
        }
        await expect(expectedError()).to.be.rejectedWith('Match error');
        unwrapUser();
      });
    });
}








